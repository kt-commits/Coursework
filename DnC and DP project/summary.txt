Final Project CSCI 570SummaryContribution by Team Members:Ankit Shah – Developing DnC algorithm, Developing basic algorithm, Shell scripts, Graph plotting, Developing space efficient alignment procedureYash Shah – Developing DnC algorithm , Developing basic algorithm, String generation, Memory and time complexity analysis.Kishan Trivedi – Developing DnC algorithm , Testing, Debugging and code refactoring, Summary report, Developing space efficient alignment procedureExplanation of the basic algorithm.1.) We first generate the input strings using a helper method and hard code the values of delta and alpha matrix.2.) Then we compute the DP table for sequence alignment. The optimal cost of the alignment would be at DP[n][m]3.) Then we back track from the optimal point to the starting point to find the actual alignment.Explanation of the efficient algorithm:1.) We first generate the input strings using a helper method and hard code the values of delta and alpha matrix.2.) Then we invoke the divide and conquer procedure on the two given strings.(X and Y)3.) This procedure divides the first string into two equal halves, XL and XR4.) Then we find the alignment cost of XL with all possible substrings of Y. This gives us an entire column of values since it contains the alignment cost with all the possible substrings.(Column1)5.) Similarly we repeat the procedure for XR(Reversed) and Y(Reversed).(Column2)6.) We get the optimal point(Ym) in the second string by adding the above two columns(first result and by finding the index of the minimum value in this added column.(Column1+Column2-reversed)7.) Then we recursively call the divide and conquer procedure on XL and YL and XR and YR, where YL(y1…ym) and YR(ym+1….yn)8.) We concatenate the results from the above subproblems, add the alignment cost and return it to the above subproblem.9.) In the base case if the length of either of the strings is less than 2, then we calculate the actual alignment and return it to the above subproblem.Observations and Insights:In the basic version of our implementation we fill the entire DP table first and backtrack from the top right corner to the origin of the DP table. This back tracking gives us the actual alignment of the sequence which minimizes the total alignment cost. This version takes around O(mn) time to complete the execution because it takes O(m*n) time to fill the dp table. This algorithm requires the entire DP table to be stored(of size [n+1][m+1]),as it is required during the actual construction of the alignment. Thus the space complexity is O(mn)In the efficient version of our implementation we use divide and conquer to decrease the memory usage of our program. We achieve this by dividing the problem into two sub-problems and recursively solving these problems. The way we do this is by dividing the first string at the middle and then finding an optimal point for division(using dynamic programming) in the second string. We then solve these two subproblems independently and concatenate their results into a single alignment. This doesn’t require the entire table to be stored in memory as we divide the problem into 2 halves. In this version, we maintain only 2 columns of size n+1 for each iteration giving us space complexity of O(m+n). However it uses approximately O(2mn) time. This is because even though, divide and conquer considers the bottom left and top right for finding the optimal split point we need to calculate the values for the complete table in every iteration. Thus it gives us cmn+ cmn/2 + cmn/4 + cmn/8 + ... = 2cmn time which is same as O(mn).